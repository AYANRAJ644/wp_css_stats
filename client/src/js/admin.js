/* global css_stats */
import Parker from 'parker/lib/Parker';
import metrics from 'parker/metrics/All';
import fetch from 'isomorphic-fetch';
import '../scss/admin.scss';

// setup parker
const parker = new Parker(metrics);
// get elements
const dataTable = document.querySelector('.css-stats-output');
const refreshBtn = document.querySelector('.css-stats-header__refresh');
const refreshClass = 'css-stats-header__refresh--loading';
const input = document.querySelector('.css-stats-header__filepath__input');
// set input as default path from wp_options
input.value = css_stats.data.filepath;
// check to see if row is already created for stat
const hasData = (rows, stat) => rows.some(row => row.dataset.stat === stat);
// create row for stats generated by parker
const createRow = (metric, data) => {
  const row = document.createElement('div');
  const metricEl = document.createElement('div');
  const dataEl = document.createElement('div');
  metricEl.innerHTML = metric;
  dataEl.innerHTML = data;
  row.classList.add('css-stats-output__row');
  row.setAttribute('data-stat', metric);
  row.appendChild(metricEl);
  row.appendChild(dataEl);
  return row;
};
// Build out stats table. Checks if table exists first.
// If it exists then we can just update the stat number.
const buildTable = (table, data) => {
  Object.keys(data).forEach((stat) => {
    const tableRows = Array.from(document.getElementsByClassName('css-stats-output__row'));
    if (hasData(tableRows, stat)) {
      const updateRow = tableRows.find(row => row.dataset.stat === stat);
      updateRow.lastElementChild.innerHTML = data[stat];
    } else {
      const row = createRow(stat, data[stat]);
      table.appendChild(row);
    }
  });
  return data;
};
// async call to fetch contents of css files return from php glob function
// runs the result through parker and build table with that data
async function fetchCss(data) {
  const css = await Promise.all(
    data.files.map(async (file) => {
      const response = await fetch(file);
      const cssData = await response.text();
      return cssData;
    }),
  );
  const stats = parker.run(css);
  buildTable(dataTable, stats);
  return data;
}
// run fetch on page load
fetchCss(css_stats.data);
// update stats on buttom press
refreshBtn.addEventListener('click', () => {
  refreshBtn.classList.add(refreshClass);
  const filepath = input.value;
  const xhr = new XMLHttpRequest();

  xhr.open('POST', `${css_stats.ajaxurl}?action=${css_stats.action}`);
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  xhr.send(`nonce=${css_stats.nonce}&filepath=${filepath}`);
  xhr.onload = () => {
    if (xhr.status === 200) {
      const response = JSON.parse(xhr.responseText);
      fetchCss(response.data);
    } else if (xhr.status !== 200) {
      console.error(`Request failed.  Returned status of ${xhr.status}`);
    }
  };
  setTimeout(() => {
    refreshBtn.classList.remove(refreshClass);
  }, 750);
});
